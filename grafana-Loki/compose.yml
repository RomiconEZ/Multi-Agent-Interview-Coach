name: monitoring  # Имя compose-проекта (используется в именах сетей/ресурсов)

x-logging: &default-logging
  driver: "json-file"  # Локальный драйвер логов Docker (ротация на стороне Docker)
  options:
    max-size: "10m"    # Максимальный размер одного файла лога контейнера
    max-file: "5"      # Количество файлов ротации

services:
  grafana:
    image: "grafana/grafana:${GRAFANA_VERSION}"  # Версия Grafana берется из .env
    container_name: grafana-central              # Явное имя контейнера (удобно для ссылок и дебага)
    restart: unless-stopped                      # Автостарт после рестарта Docker/хоста, но не после ручного stop
    ports:
      - "${GRAFANA_PORT_EXTERNAL:-3000}:3000"    # Публикация UI Grafana на хост
    environment:
      GF_LOG_LEVEL: "${GRAFANA_LOG_LEVEL}"       # Уровень логов Grafana
      GF_LOG_MODE: "${GRAFANA_LOG_MODE}"         # Режим логирования Grafana

      GF_AUTH_ANONYMOUS_ENABLED: "${GRAFANA_ANONYMOUS_ENABLED}"  # Анонимный доступ
      GF_AUTH_ANONYMOUS_ORG_ROLE: "${GRAFANA_ANONYMOUS_ORG_ROLE}"# Роль анонима
      GF_SECURITY_ALLOW_EMBEDDING: "${GRAFANA_ALLOW_EMBEDDING}"  # Разрешение embed/iframe

      GF_SECURITY_ADMIN_USER: "${GRAFANA_ADMIN_USER}"            # Админ-логин
      GF_SECURITY_ADMIN_PASSWORD: "${GRAFANA_ADMIN_PASSWORD:-admin}" # Админ-пароль (fallback на admin)

      GF_PLUGINS_PREINSTALL: "${GRAFANA_PLUGINS_PREINSTALL}"     # Список плагинов для preinstall

      GF_RENDERING_SERVER_URL: "${GRAFANA_RENDERING_SERVER_URL}" # Куда Grafana отправляет запросы рендеринга
      GF_RENDERING_CALLBACK_URL: "${GRAFANA_RENDERING_CALLBACK_URL}" # Как renderer обращается к Grafana
      GF_RENDERING_RENDERER_TOKEN: "${GRAFANA_RENDERER_TOKEN}"    # Токен между Grafana и renderer

      GF_METRICS_ENABLED: "${GRAFANA_METRICS_ENABLED}"           # Включение /metrics

      LOKI_TENANT_ID: "${LOKI_TENANT_ID}"                        # Проброс tenant id в окружение (в т.ч. для провижининга)
    volumes:
      - grafana_data:/var/lib/grafana                            # Персистентные данные Grafana (БД, плагины)
      - ./grafana/provisioning:/etc/grafana/provisioning:ro      # Провижининг datasources/dashboards (read-only)
      - ./grafana/dashboards:/var/lib/grafana/dashboards:ro      # Локальные дашборды для провижининга (read-only)
    depends_on:
      prometheus:
        condition: service_started                               # Grafana зависит от поднятого Prometheus
      loki:
        condition: service_started                               # Grafana зависит от старта Loki (без проверки здоровья)
      grafana-renderer:
        condition: service_started                               # Grafana зависит от renderer
    healthcheck:
      test: [ "CMD-SHELL", "wget -qO- http://localhost:3000/api/health | grep -q '\"database\"' || exit 1" ] # Проверка здоровья Grafana через API
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 40s

  grafana-renderer:
    image: "grafana/grafana-image-renderer:${GRAFANA_RENDERER_VERSION}" # Версия renderer из .env
    container_name: grafana-renderer
    restart: unless-stopped                      # Автостарт после рестарта Docker/хоста
    logging: *default-logging
    environment:
      AUTH_TOKEN: "${GRAFANA_RENDERER_TOKEN}"     # Токен авторизации, должен совпадать с Grafana
      LOG_LEVEL: "error"                          # Уровень логов renderer (фиксированно)
      ENABLE_METRICS: "true"                      # Включение метрик renderer
      GOMEMLIMIT: "${GRAFANA_RENDERER_GOMEMLIMIT}"# Лимит памяти Go runtime
    healthcheck:
      test: [ "CMD-SHELL", "wget -qO- http://localhost:8081/healthz | grep -qi ok || exit 1" ] # Проверка /healthz у renderer
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 40s

  loki-data-init:
    image: "busybox:1.37.0"
    container_name: loki-data-init
    command:
      - sh
      - -c
      - >
        set -eu;
        mkdir -p /loki/bin;
        cp /bin/busybox /loki/bin/busybox;
        chmod 0755 /loki/bin/busybox;
        mkdir -p /loki/chunks /loki/rules /loki/rules_temp /loki/index /loki/index_cache /loki/compactor /loki/wal;
        chown -R 10001:10001 /loki
    volumes:
      - loki_data:/loki
    restart: "no"

  loki:
    image: "grafana/loki:${LOKI_VERSION}"         # Версия Loki из .env
    container_name: loki-central
    user: "10001:10001"
    restart: unless-stopped                      # Автостарт после рестарта Docker/хоста
    logging: *default-logging
    ports:
      - "${LOKI_PORT_EXTERNAL:-3100}:3100"        # Loki HTTP API порт
      - "${LOKI_GRPC_PORT_EXTERNAL:-9095}:9095"   # Loki gRPC порт
    environment:
      LOKI_TENANT_ID: "${LOKI_TENANT_ID}"         # Tenant id (используется в healthcheck header и может быть нужен окружению)
      LOKI_LOG_LEVEL: "${LOKI_LOG_LEVEL}"         # Loki log level injected into loki-config.yaml via -config.expand-env
    command:
      - -config.file=/etc/loki/local-config.yaml  # Путь к конфигу Loki
      - -config.expand-env=true                   # Enable environment variable expansion inside YAML config
      - -target=all                               # Запуск всех компонентов в одном процессе (all-in-one)
    volumes:
      - loki_data:/loki                           # Данные Loki (чанки/индексы/правила)
      - ./loki/loki-config.yaml:/etc/loki/local-config.yaml:ro # Конфиг Loki (read-only)
    depends_on:
      loki-data-init:
        condition: service_completed_successfully

volumes:
  grafana_data:      # Volume для данных Grafana
  loki_data:         # Volume для данных Loki